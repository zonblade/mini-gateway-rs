<!-- NodeEditor.svelte -->
<script>
    import { onMount, onDestroy } from "svelte";

    // Canvas dimensions - will be updated to match parent
    let dimensions = { width: 1000, height: 700 };

    // Container reference
    let container;

    // Canvas reference
    let canvas;
    let ctx;

    // Debug mode
    let isDebug = true;

    // Viewport transform - starting with neutral values
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isPanning = false;
    let lastPanPoint = { x: 0, y: 0 };

    // Sample data based on the provided structure
    let nodes = [
        {
            id: "node1",
            type: "Proxy",
            name: "Some proxy",
            relation: ["node2", "node3"],
            field: [{ title: "Listen", value: "0.0.0.0:123" }],
            width: 200,
        },
        {
            id: "node2",
            type: "Domain",
            name: "Something.com",
            relation: ["node3"],
            field: [{ title: "TLS", value: "Enabled" }],
            width: 200,
        },
        {
            id: "node3",
            type: "Gateway",
            name: "some title",
            relation: [],
            field: [{ title: "TLS", value: "Enabled" }],
            width: 200,
        },
    ];

    // Force-directed layout parameters - will be adjusted dynamically
    let REPULSION_FORCE = 12000; // Reduced from 20000 for less repulsion
    let ATTRACTION_FORCE = 0.08; // Increased slightly from 0.06
    let DAMPING = 0.85; 
    let MIN_DISTANCE = 300; // Reduced from 400 for tighter layout
    let ITERATIONS = 180; // Slightly reduced from 200

    // Enhanced collision avoidance parameters
    let ENHANCED_REPULSION_FORCE = 15000; // Base repulsion force
    let ENHANCED_ATTRACTION_FORCE = 0.09; // Base attraction force
    let ENHANCED_DAMPING = 0.82;          // Base damping coefficient
    let ENHANCED_MIN_DISTANCE = 300;      // Minimum distance to maintain between nodes

    // Layout parameters for hierarchical layout - adding missing declarations
    let LEVEL_HEIGHT = 350;
    let LEVEL_HORIZONTAL_SPACING = 100;

    // Initialize the node positions with large initial spacing before the layout algorithm runs
    function initializeNodePlacement() {
        const gridCols = Math.ceil(Math.sqrt(nodes.length));
        const spacing = 600; // Reduced from 800 for less initial spacing
        
        nodes = nodes.map((node, index) => {
            // Add some randomness to initial placement to avoid grid alignment
            const jitter = Math.random() * 100 - 50; // Reduced jitter from ±100 to ±50
            const col = index % gridCols;
            const row = Math.floor(index / gridCols);
            
            // Position nodes in a grid initially with jitter
            return {
                ...node,
                x: (col - Math.floor(gridCols / 2)) * spacing + jitter,
                y: row * spacing + jitter
            };
        });
    }

    // Calculate optimal layout parameters based on canvas size and node count
    function calculateLayoutParameters() {
        // Adapt layout parameters based on canvas size and node count
        const nodeCount = nodes.length;
        const aspect = dimensions.width / dimensions.height;
        
        // Base values
        let levelHeight = 350;
        let horizontalSpacing = 100;
        let repulsionForce = 15000;
        
        // Adjust for small canvases
        if (dimensions.width < 800 || dimensions.height < 600) {
            levelHeight = 250;
            horizontalSpacing = 80;
            repulsionForce = 12000;
        }
        
        // Adjust for many nodes
        if (nodeCount > 10) {
            levelHeight = Math.max(200, levelHeight - (nodeCount - 10) * 10);
            horizontalSpacing = Math.max(60, horizontalSpacing - (nodeCount - 10) * 5);
        }
        
        // Adjust for canvas aspect ratio
        if (aspect > 1.5) {
            // Wide canvas - favor horizontal layout
            levelHeight = levelHeight * 0.8;
            horizontalSpacing = horizontalSpacing * 1.2;
        } else if (aspect < 0.8) {
            // Tall canvas - favor vertical layout
            levelHeight = levelHeight * 1.2;
            horizontalSpacing = horizontalSpacing * 0.8;
        }
        
        return {
            LEVEL_HEIGHT: levelHeight,
            LEVEL_HORIZONTAL_SPACING: horizontalSpacing,
            REPULSION_FORCE: repulsionForce
        };
    }

    // Initialize physics properties for nodes
    function initializePhysics(nodeList) {
        return nodeList.map(node => ({
            ...node,
            // Initialize velocity
            vx: 0,
            vy: 0,
            // Initialize force
            fx: 0,
            fy: 0
        }));
    }

    // === ENHANCED FORCE-DIRECTED LAYOUT WITH QUADTREE COLLISION DETECTION ===
    
    // Create a quadtree data structure for efficient spatial queries
    function createQuadtree(physicsNodes) {
        // Determine bounds of all nodes
        const bounds = calculateBounds(physicsNodes.map(node => ({ x: node.x, y: node.y })));
        
        // Add padding to bounds
        const padding = 100;
        bounds.minX -= padding;
        bounds.minY -= padding;
        bounds.maxX += padding;
        bounds.maxY += padding;
        
        // Create a simplified quadtree implementation
        const quadtree = {
            bounds,
            nodes: [...physicsNodes],
            find: function(x, y, radius) {
                // Find all nodes within radius of point (x, y)
                return this.nodes.filter(node => {
                    const dx = node.x - x;
                    const dy = node.y - y;
                    const distanceSq = dx * dx + dy * dy;
                    return distanceSq <= radius * radius;
                });
            }
        };
        
        return quadtree;
    }

    // Update the quadtree with new node positions
    function updateQuadtree(quadtree, physicsNodes) {
        // In this simplified implementation, we just update the nodes reference
        quadtree.nodes = [...physicsNodes];
    }

    // Apply repulsion forces between nodes using the quadtree for efficiency
    function applyRepulsionForces(physicsNodes, quadtree, iteration, totalIterations) {
        // Adjust repulsion strength based on iteration progress for smoother convergence
        const progressFactor = 1 - (iteration / totalIterations) * 0.3;
        const adjustedRepulsionForce = ENHANCED_REPULSION_FORCE * progressFactor;
        
        // Process each node to apply repulsion forces
        for (let i = 0; i < physicsNodes.length; i++) {
            const nodeA = physicsNodes[i];
            
            // Calculate node dimensions
            const nodeAHeight = calculateNodeHeight(nodeA);
            const halfWidthA = nodeA.width / 2;
            const halfHeightA = nodeAHeight / 2;
            
            // Define search radius - use the maximum of node dimensions plus buffer
            const searchRadius = Math.max(halfWidthA, halfHeightA) + ENHANCED_MIN_DISTANCE;
            
            // Use quadtree to find nearby nodes efficiently
            const nearbyNodes = quadtree.find(nodeA.x, nodeA.y, searchRadius);
            
            for (let j = 0; j < nearbyNodes.length; j++) {
                const nodeB = nearbyNodes[j];
                
                // Skip self-comparisons
                if (nodeA === nodeB) continue;
                
                // Calculate distance vector between node centers
                const dx = nodeB.x - nodeA.x;
                const dy = nodeB.y - nodeA.y;
                
                // Calculate distance (avoid division by zero)
                const distanceSq = dx * dx + dy * dy;
                const distance = Math.sqrt(distanceSq) || 0.1;
                
                // Calculate node dimensions for collision detection
                const nodeBHeight = calculateNodeHeight(nodeB);
                const halfWidthB = nodeB.width / 2;
                const halfHeightB = nodeBHeight / 2;
                
                // Calculate minimum distance needed to avoid overlap in each direction
                const minDistanceX = halfWidthA + halfWidthB + 30; // Buffer to avoid touching
                const minDistanceY = halfHeightA + halfHeightB + 30;
                
                // Check for overlap
                const isOverlappingX = Math.abs(dx) < minDistanceX;
                const isOverlappingY = Math.abs(dy) < minDistanceY;
                const isOverlapping = isOverlappingX && isOverlappingY;
                
                // Calculate repulsion factor based on overlap state
                let repulsionFactor = 1.0;
                
                if (isOverlapping) {
                    // Use a smooth repulsion factor based on overlap amount
                    const overlapDistanceX = minDistanceX - Math.abs(dx);
                    const overlapDistanceY = minDistanceY - Math.abs(dy);
                    const overlapRatio = Math.min(
                        1.0, 
                        Math.max(overlapDistanceX / minDistanceX, overlapDistanceY / minDistanceY)
                    );
                    
                    // Apply a stronger repulsion for greater overlap
                    repulsionFactor = 1.0 + 7.0 * overlapRatio;
                    
                    // Add directional forces proportional to the overlap in each direction
                    const overlapFactorX = isOverlappingX ? overlapDistanceX / minDistanceX * 10 : 0;
                    const overlapFactorY = isOverlappingY ? overlapDistanceY / minDistanceY * 10 : 0;
                    
                    // Apply extra forces in the direction of overlap
                    const extraForceX = Math.sign(dx) * overlapFactorX * adjustedRepulsionForce * 0.15;
                    const extraForceY = Math.sign(dy) * overlapFactorY * adjustedRepulsionForce * 0.15;
                    
                    // Apply extra directional forces - stronger for more significant overlaps
                    nodeA.fx -= extraForceX;
                    nodeA.fy -= extraForceY;
                    nodeB.fx += extraForceX;
                    nodeB.fy += extraForceY;
                } else if (distance < ENHANCED_MIN_DISTANCE) {
                    // Medium repulsion for nodes that are close but not overlapping
                    // Use a smooth falloff as distance approaches MIN_DISTANCE
                    repulsionFactor = 1.5 * Math.pow(1 - distance / ENHANCED_MIN_DISTANCE, 2);
                }
                
                // Calculate normalized direction vector
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Calculate inverse-square repulsion force with adjusted strength
                // Use squared distance for physical accuracy but with a minimum to avoid excessive forces
                const force = (adjustedRepulsionForce * repulsionFactor) / Math.max(distanceSq, 100);
                
                // Apply force in opposite directions
                nodeA.fx -= nx * force;
                nodeA.fy -= ny * force;
                nodeB.fx += nx * force;
                nodeB.fy += ny * force;
            }
        }
    }

    // Apply attraction forces based on connections
    function applyAttractionForces(physicsNodes, connections) {
        connections.forEach(connection => {
            const source = physicsNodes.find(n => n.id === connection.from.nodeId);
            const target = physicsNodes.find(n => n.id === connection.to.nodeId);
            
            if (source && target) {
                // Calculate distance vector
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                
                // Calculate distance
                const distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
                
                // Use a non-linear attraction that increases with distance
                // This avoids excessive compression of the graph
                const maxAttractDistance = 250;
                const attractionMultiplier = Math.min(1.0, distance / maxAttractDistance);
                const force = ENHANCED_ATTRACTION_FORCE * distance * attractionMultiplier;
                
                // Calculate normalized direction vector
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Apply force to both nodes, pulling them together
                source.fx += nx * force;
                source.fy += ny * force;
                target.fx -= nx * force;
                target.fy -= ny * force;
            }
        });
    }

    // Apply a gentle gravity force to keep nodes from drifting too far
    function applyGravityForces(physicsNodes) {
        physicsNodes.forEach(node => {
            const dx = -node.x;
            const dy = -node.y;
            const distance = Math.sqrt(dx * dx + dy * dy) || 0.1;
            
            // Only apply gravity for nodes far from center
            if (distance > 500) {
                const gravityForce = 0.02; // Gentle gravity coefficient
                const nx = dx / distance;
                const ny = dy / distance;
                
                // Apply gentle gravity proportional to distance from center
                node.fx += nx * gravityForce * (distance - 500);
                node.fy += ny * gravityForce * (distance - 500);
            }
        });
    }

    // Update node positions based on calculated forces
    function updatePositions(physicsNodes, iteration, totalIterations) {
        // Calculate adaptive damping based on iteration progress
        // Start with lower damping (more movement) and increase towards end (more stability)
        const progressRatio = iteration / totalIterations;
        const adaptiveDamping = ENHANCED_DAMPING + (0.95 - ENHANCED_DAMPING) * Math.pow(progressRatio, 2);
        
        physicsNodes.forEach(node => {
            // Update velocity with damping
            node.vx = node.vx * adaptiveDamping + node.fx;
            node.vy = node.vy * adaptiveDamping + node.fy;
            
            // Apply additional damping in late iterations for better convergence
            if (progressRatio > 0.7) {
                const finalDamping = 0.65;
                const dampingFactor = finalDamping + (adaptiveDamping - finalDamping) * 
                                    (1.0 - (progressRatio - 0.7) / 0.3);
                node.vx *= dampingFactor;
                node.vy *= dampingFactor;
            }
            
            // Limit maximum velocity to avoid explosive movement
            const maxVelocity = 20; // Maximum allowed velocity
            const velocityMagnitude = Math.sqrt(node.vx * node.vx + node.vy * node.vy);
            
            if (velocityMagnitude > maxVelocity) {
                const scale = maxVelocity / velocityMagnitude;
                node.vx *= scale;
                node.vy *= scale;
            }
            
            // Update position
            node.x += node.vx;
            node.y += node.vy;
        });
    }

    // Keep nodes within reasonable bounds
    function constrainPositions(physicsNodes) {
        // Calculate current bounds
        const nodePositions = physicsNodes.map(node => ({ x: node.x, y: node.y }));
        const bounds = calculateBounds(nodePositions);
        
        // Get dimensions
        const width = bounds.maxX - bounds.minX;
        const height = bounds.maxY - bounds.minY;
        const maxDimension = Math.max(width, height);
        
        // Constrain if too large
        if (maxDimension > 1800) {
            const compressionFactor = 1800 / maxDimension;
            const centerX = (bounds.minX + bounds.maxX) / 2;
            const centerY = (bounds.minY + bounds.maxY) / 2;
            
            // Compress towards center to maintain relative positioning
            physicsNodes.forEach(node => {
                // Calculate vector from center
                const dx = node.x - centerX;
                const dy = node.y - centerY;
                
                // Apply compression
                node.x = centerX + dx * compressionFactor;
                node.y = centerY + dy * compressionFactor;
            });
        }
    }

    // Enhanced force-directed layout with improved collision detection
    function runForceLayout(iterations = ITERATIONS) {
        console.log("Running enhanced force layout with quadtree collision detection...");
        
        // Clone the nodes array to avoid reactive updates during calculation
        let physicsNodes = initializePhysics([...nodes]);
        
        // Set up a quadtree for efficient collision detection
        const quadtree = createQuadtree(physicsNodes);
        
        // Run simulation for a fixed number of iterations
        for (let i = 0; i < iterations; i++) {
            // Reset forces
            physicsNodes.forEach(node => {
                node.fx = 0;
                node.fy = 0;
            });
            
            // Apply repulsion forces using the quadtree for efficiency
            applyRepulsionForces(physicsNodes, quadtree, i, iterations);
            
            // Calculate attraction forces based on connections
            applyAttractionForces(physicsNodes, connections);
            
            // Apply a small gravity toward center to prevent disconnected components from drifting
            applyGravityForces(physicsNodes);
            
            // Update velocities and positions with adaptive damping
            updatePositions(physicsNodes, i, iterations);
            
            // Apply position constraints to keep nodes within reasonable bounds
            constrainPositions(physicsNodes);
            
            // Update the quadtree with new positions
            updateQuadtree(quadtree, physicsNodes);
        }
        
        // Update the actual nodes with new positions
        nodes = physicsNodes.map(({ id, x, y, vx, vy, fx, fy, order, barycenter, ...rest }) => ({
            id,
            x,
            y,
            ...rest
        }));
        
        // Re-render the canvas
        render();
    }

    // Completely revised hierarchical layout function
    function runHierarchicalLayout() {
        // First analyze the graph structure
        const incomingConnections = new Map();
        const outgoingConnections = new Map();
        
        // Initialize all nodes
        nodes.forEach(node => {
            incomingConnections.set(node.id, []);
            outgoingConnections.set(node.id, []);
        });
        
        // Map connection structure
        connections.forEach(conn => {
            const sourceId = conn.from.nodeId;
            const targetId = conn.to.nodeId;
            
            outgoingConnections.get(sourceId).push(targetId);
            incomingConnections.get(targetId).push(sourceId);
        });
        
        // Find root nodes (nodes with no incoming connections)
        const rootNodes = nodes
            .filter(node => incomingConnections.get(node.id).length === 0)
            .map(node => node.id);
        
        // If no root nodes found, pick the nodes with the fewest incoming connections
        if (rootNodes.length === 0 && nodes.length > 0) {
            let minIncoming = Infinity;
            nodes.forEach(node => {
                const count = incomingConnections.get(node.id).length;
                if (count < minIncoming) {
                    minIncoming = count;
                }
            });
            
            nodes.forEach(node => {
                if (incomingConnections.get(node.id).length === minIncoming) {
                    rootNodes.push(node.id);
                }
            });
        }
        
        // Assign levels to nodes using topological sorting
        const levels = new Map();
        const visited = new Set();
        
        // Use a topological sort to determine levels
        function topologicalSort() {
            const temporaryMarked = new Set();
            let currentLevel = 0;
            const result = [];
            
            function visit(nodeId, level) {
                if (temporaryMarked.has(nodeId)) {
                    // Cycle detected - break it
                    return;
                }
                
                if (!visited.has(nodeId)) {
                    temporaryMarked.add(nodeId);
                    
                    // Process outgoing connections
                    outgoingConnections.get(nodeId).forEach(targetId => {
                        visit(targetId, level + 1);
                    });
                    
                    visited.add(nodeId);
                    temporaryMarked.delete(nodeId);
                    
                    // Assign level - nodes should be at a level AFTER all their incoming nodes
                    const nodeLevel = Math.max(
                        level,
                        ...incomingConnections.get(nodeId).map(sourceId => 
                            levels.get(sourceId) !== undefined ? levels.get(sourceId) + 1 : level
                        )
                    );
                    
                    levels.set(nodeId, nodeLevel);
                    result.push(nodeId);
                }
            }
            
            // Start with root nodes at level 0
            rootNodes.forEach(nodeId => {
                visit(nodeId, 0);
            });
            
            // Process any disconnected nodes
            nodes.forEach(node => {
                if (!visited.has(node.id)) {
                    visit(node.id, 0);
                }
            });
            
            return result.reverse();
        }
        
        topologicalSort();
        
        // Handle any unassigned nodes (disconnected components)
        nodes.forEach(node => {
            if (!levels.has(node.id)) {
                levels.set(node.id, 0);
            }
        });
        
        // Find max level to normalize levels if needed
        let maxLevel = 0;
        levels.forEach(level => {
            maxLevel = Math.max(maxLevel, level);
        });
        
        // Group nodes by level
        const nodesByLevel = new Map();
        
        nodes.forEach(node => {
            const level = levels.get(node.id);
            if (!nodesByLevel.has(level)) {
                nodesByLevel.set(level, []);
            }
            nodesByLevel.get(level).push(node);
        });
        
        // Sort nodes within each level to minimize edge crossings
        // Uses barycentric method - position nodes based on average position of connected nodes
        for (let i = 0; i < maxLevel; i++) {
            const currentLevelNodes = nodesByLevel.get(i) || [];
            const nextLevelNodes = nodesByLevel.get(i + 1) || [];
            
            if (currentLevelNodes.length > 0 && nextLevelNodes.length > 0) {
                // First assign positions to current level if it's the first level
                if (i === 0) {
                    currentLevelNodes.forEach((node, index) => {
                        node.order = index;
                    });
                }
                
                // Assign barycentric weights to next level based on connected node positions
                nextLevelNodes.forEach(node => {
                    // Find all incoming connections from current level
                    const connectedNodeIds = incomingConnections.get(node.id)
                        .filter(sourceId => levels.get(sourceId) === i);
                    
                    if (connectedNodeIds.length > 0) {
                        // Calculate average position of connected nodes
                        const totalPosition = connectedNodeIds.reduce((sum, sourceId) => {
                            const sourceNode = currentLevelNodes.find(n => n.id === sourceId);
                            return sum + (sourceNode ? sourceNode.order : 0);
                        }, 0);
                        
                        node.barycenter = totalPosition / connectedNodeIds.length;
                    } else {
                        // If no connections, assign a default position
                        node.barycenter = nextLevelNodes.length / 2;
                    }
                });
                
                // Sort next level nodes by their barycentric weight
                nextLevelNodes.sort((a, b) => a.barycenter - b.barycenter);
                
                // Update order
                nextLevelNodes.forEach((node, index) => {
                    node.order = index;
                });
            }
        }
        
        // Position nodes based on levels and orders
        const NODE_WIDTH = 200;  // Default node width
        
        // For each level, position nodes horizontally
        nodesByLevel.forEach((levelNodes, level) => {
            // Sort nodes by order (if it exists from barycentric sorting)
            levelNodes.sort((a, b) => {
                if (a.order !== undefined && b.order !== undefined) {
                    return a.order - b.order;
                }
                return 0;
            });
            
            // Calculate total width needed for this level
            const totalWidth = levelNodes.length * NODE_WIDTH + 
                             (levelNodes.length - 1) * LEVEL_HORIZONTAL_SPACING;
            
            // Calculate starting x position to center this level
            const startX = -totalWidth / 2;
            
            // Position each node in the level
            levelNodes.forEach((node, index) => {
                const x = startX + index * (NODE_WIDTH + LEVEL_HORIZONTAL_SPACING) + (NODE_WIDTH / 2);
                const y = level * LEVEL_HEIGHT;
                
                // Update node position
                nodes = nodes.map(n => {
                    if (n.id === node.id) {
                        return { ...n, x, y };
                    }
                    return n;
                });
            });
        });
        
        // Apply force-directed layout for fine-tuning with fewer iterations
        runForceLayout(50);
        
        // Re-render the canvas
        render();
    }

    // Updated auto layout function
    function autoLayout() {
        console.log("Running auto layout with enhanced collision avoidance...");
        
        // Calculate optimal layout parameters based on current state
        const layoutParams = calculateLayoutParameters();
        
        // Apply to global variables
        if (layoutParams.LEVEL_HEIGHT) {
            LEVEL_HEIGHT = layoutParams.LEVEL_HEIGHT;
        }
        
        if (layoutParams.LEVEL_HORIZONTAL_SPACING) {
            LEVEL_HORIZONTAL_SPACING = layoutParams.LEVEL_HORIZONTAL_SPACING;
        }
        
        // Apply repulsion force if calculated and update enhanced parameters
        if (layoutParams.REPULSION_FORCE) {
            REPULSION_FORCE = layoutParams.REPULSION_FORCE;
            ENHANCED_REPULSION_FORCE = REPULSION_FORCE * 1.25; // Slightly stronger for better collision avoidance
        }
        
        // Initialize positions before running the layout algorithm
        initializeNodePlacement();
        
        // For smaller graphs, hierarchical layout works best
        if (nodes.length <= 15) {
            runHierarchicalLayout();
            // Apply enhanced force layout with fewer iterations for fine-tuning
            runForceLayout(50);
        } else {
            // For larger graphs, pure force-directed works better
            runForceLayout(200); // More iterations for better layout
        }
        
        // Fit view after layout with a slight delay to ensure rendering
        setTimeout(fitView, 100);
    }

    // Helper function to calculate bounds of node positions
    function calculateBounds(positions) {
        let minX = Infinity, minY = Infinity;
        let maxX = -Infinity, maxY = -Infinity;
        
        positions.forEach(pos => {
            minX = Math.min(minX, pos.x);
            minY = Math.min(minY, pos.y);
            maxX = Math.max(maxX, pos.x);
            maxY = Math.max(maxY, pos.y);
        });
        
        return {
            minX, minY, maxX, maxY,
            width: maxX - minX,
            height: maxY - minY
        };
    }

    // Automatically add input/output ports based on node type and relations
    $: nodesWithPorts = nodes.map((node) => {
        // Determine if this node type should have inputs/outputs
        let hasInputs = node.type !== "Proxy"; // Proxy doesn't have inputs
        let hasOutputs = node.type !== "Gateway"; // Gateway doesn't have outputs

        // Create inputs and outputs
        const inputs = hasInputs
            ? [{ id: "in1", name: "In", type: "connection" }]
            : [];
        const outputs = hasOutputs
            ? [{ id: "out1", name: "Out", type: "connection" }]
            : [];

        return { ...node, inputs, outputs };
    });

    // Generate connections based on node relations
    $: connections = generateConnectionsFromRelations(nodesWithPorts);

    function generateConnectionsFromRelations(nodeList) {
        let generatedConnections = [];
        let connectionId = 1;

        nodeList.forEach((node) => {
            if (node.relation && node.relation.length > 0) {
                node.relation.forEach((targetId) => {
                    const targetNode = nodeList.find((n) => n.id === targetId);
                    if (targetNode && node.outputs && targetNode.inputs) {
                        generatedConnections.push({
                            id: connectionId++,
                            from: { nodeId: node.id, portId: "out1" },
                            to: { nodeId: targetId, portId: "in1" },
                        });
                    }
                });
            }
        });

        return generatedConnections;
    }

    // Dragging state
    let draggedNode = null;
    let dragOffset = { x: 0, y: 0 };

    // Mouse position tracking (keeping this for other features)
    let mousePos = { x: 0, y: 0 };

    // Node editing state
    let editingNode = null;

    // Calculate node height based on fields
    function calculateNodeHeight(node) {
        // Base height plus space for each field
        const baseHeight = 80;
        const fieldHeight = 25;
        const fieldCount = node.field ? node.field.length : 0;
        return baseHeight + fieldCount * fieldHeight;
    }

    // Calculate port positions - this needs to run whenever nodes change
    $: nodesWithPortPositions = nodesWithPorts.map((node) => {
        // Update height based on fields
        const height = calculateNodeHeight(node);

        const inputs =
            node.inputs?.map((input, index) => {
                const x = node.x;
                const y = node.y + 40 + index * 25;
                return { ...input, position: { x, y } };
            }) || [];

        const outputs =
            node.outputs?.map((output, index) => {
                const x = node.x + node.width;
                const y = node.y + 40 + index * 25;
                return { ...output, position: { x, y } };
            }) || [];

        return { ...node, height, inputs, outputs };
    });

    // Convert screen coordinates to world coordinates
    function screenToWorld(screenX, screenY) {
        return {
            x: (screenX - offsetX) / scale,
            y: (screenY - offsetY) / scale,
        };
    }

    // Convert world coordinates to screen coordinates
    function worldToScreen(worldX, worldY) {
        return {
            x: worldX * scale + offsetX,
            y: worldY * scale + offsetY,
        };
    }

    // Handle canvas resize
    let resizeObserver;

    function setupResizeObserver() {
        resizeObserver = new ResizeObserver((entries) => {
            for (let entry of entries) {
                const { width, height } = entry.contentRect;
                dimensions = { width, height };
                canvas.width = width;
                canvas.height = height;
                render();
            }
        });

        resizeObserver.observe(container);
    }

    // Handle node dragging
    function handleMouseDown(e, nodeId) {
        // Check if we're starting panning (middle mouse button)
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
            e.preventDefault();
            isPanning = true;
            lastPanPoint = { x: e.clientX, y: e.clientY };
            return;
        }

        // Left mouse button for node dragging
        if (e.button === 0) {
            const node = nodes.find((n) => n.id === nodeId);
            if (node) {
                const rect = canvas.getBoundingClientRect();
                const screenX = e.clientX - rect.left;
                const screenY = e.clientY - rect.top;
                const world = screenToWorld(screenX, screenY);

                draggedNode = nodeId;
                dragOffset = {
                    x: world.x - node.x,
                    y: world.y - node.y,
                };
            }
        }
    }

    function handleCanvasMouseDown(e) {
        // Check if we're starting panning (middle mouse button or Alt+Left)
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
            e.preventDefault();
            isPanning = true;
            lastPanPoint = { x: e.clientX, y: e.clientY };
            return;
        }

        // Check if clicked on a node
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const world = screenToWorld(screenX, screenY);

        const clickedNode = nodesWithPortPositions.find(
            (node) =>
                world.x >= node.x &&
                world.x <= node.x + node.width &&
                world.y >= node.y &&
                world.y <= node.y + node.height,
        );

        if (clickedNode) {
            handleMouseDown(e, clickedNode.id);
        }
    }

    function handleMouseMove(e) {
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;

        // Handle panning
        if (isPanning) {
            const dx = e.clientX - lastPanPoint.x;
            const dy = e.clientY - lastPanPoint.y;

            offsetX += dx;
            offsetY += dy;

            lastPanPoint = { x: e.clientX, y: e.clientY };
            render();
            return;
        }

        // Convert to world coordinates
        const world = screenToWorld(screenX, screenY);
        mousePos = world;

        // Handle node dragging
        if (draggedNode !== null) {
            nodes = nodes.map((node) => {
                if (node.id === draggedNode) {
                    return {
                        ...node,
                        x: world.x - dragOffset.x,
                        y: world.y - dragOffset.y,
                    };
                }
                return node;
            });
        }
    }

    function handleMouseUp(e) {
        // Stop panning
        if (isPanning) {
            isPanning = false;
            return;
        }

        draggedNode = null;
    }

    // Handle wheel event for zooming
    function handleWheel(e) {
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Convert mouse position to world space before zoom
        const worldMouseX = (mouseX - offsetX) / scale;
        const worldMouseY = (mouseY - offsetY) / scale;

        // Adjust zoom level
        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1; // Zoom out or in
        scale = Math.max(0.1, Math.min(scale * zoomFactor, 5)); // Limit scale between 0.1 and 5

        // Adjust offset to zoom towards mouse position
        offsetX = mouseX - worldMouseX * scale;
        offsetY = mouseY - worldMouseY * scale;

        render();
    }

    // Recenter view to fit all nodes
    function fitView() {
        if (nodes.length === 0) return;

        // Find bounds of all nodes
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;

        nodes.forEach((node) => {
            minX = Math.min(minX, node.x);
            minY = Math.min(minY, node.y);
            maxX = Math.max(maxX, node.x + node.width);
            maxY = Math.max(maxY, node.y + calculateNodeHeight(node));
        });

        // Add padding
        const padding = 50;
        minX -= padding;
        minY -= padding;
        maxX += padding;
        maxY += padding;

        // Calculate required scale
        const scaleX = dimensions.width / (maxX - minX);
        const scaleY = dimensions.height / (maxY - minY);
        scale = Math.min(scaleX, scaleY, 1); // Don't zoom in more than 1x

        // Center the content
        offsetX = (dimensions.width - (maxX - minX) * scale) / 2 - minX * scale;
        offsetY =
            (dimensions.height - (maxY - minY) * scale) / 2 - minY * scale;

        render();
    }

    // Reset view to default
    function resetView() {
        scale = 1;
        offsetX = 0;
        offsetY = 0;
        render();
    }

    // Handle port mouse interaction (simplified version)
    function handlePortMouseDown(e, nodeId, portId, isOutput) {
        e.stopPropagation();
        // We no longer initiate connections - function kept for possible future use
    }

    // Double click to edit node
    function handleNodeDoubleClick(e, nodeId) {
        e.stopPropagation();
        editingNode = nodes.find((n) => n.id === nodeId);
    }

    // Save edited node
    function saveEditingNode() {
        if (!editingNode) return;

        nodes = nodes.map((node) => {
            if (node.id === editingNode.id) {
                return { ...editingNode };
            }
            return node;
        });

        editingNode = null;
    }

    function cancelEditingNode() {
        editingNode = null;
    }

    // Add a new field to the editing node
    function addField() {
        if (!editingNode) return;

        editingNode = {
            ...editingNode,
            field: [
                ...editingNode.field,
                { title: "New Field", value: "Value" },
            ],
        };
    }

    // Update field value
    function updateField(index, property, value) {
        if (!editingNode) return;

        const updatedFields = [...editingNode.field];
        updatedFields[index] = {
            ...updatedFields[index],
            [property]: value,
        };

        editingNode = {
            ...editingNode,
            field: updatedFields,
        };
    }

    // Delete a field
    function deleteField(index) {
        if (!editingNode) return;

        const updatedFields = editingNode.field.filter((_, i) => i !== index);

        editingNode = {
            ...editingNode,
            field: updatedFields,
        };
    }

    // Helper function to draw a bezier connection
    function drawBezierConnection(ctx, x1, y1, x2, y2) {
        const midX = x1 + (x2 - x1) * 0.5;

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.bezierCurveTo(midX, y1, midX, y2, x2, y2);
        ctx.stroke();
    }

    // Helper function to draw rounded rectangles
    function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
            x + width,
            y + height,
            x + width - radius,
            y + height,
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        if (fill) {
            ctx.fill();
        }
        if (stroke) {
            ctx.stroke();
        }
    }

    // Theme state
    let isDarkTheme =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

    // Theme-aware colors
    function getBackgroundColor() {
        return isDarkTheme ? "#1e1e1e" : "#fafafa";
    }

    function getTextColor() {
        return isDarkTheme ? "#e0e0e0" : "#333333";
    }

    function getNodeColor(type) {
        if (isDarkTheme) {
            switch (type) {
                case "Proxy":
                    return "#1a3b5c"; // Dark blue
                case "Domain":
                    return "#1b3b2c"; // Dark green
                case "Gateway":
                    return "#3b2e1b"; // Dark orange
                default:
                    return "#2d2d2d";
            }
        } else {
            switch (type) {
                case "Proxy":
                    return "#e3f2fd";
                case "Domain":
                    return "#e8f5e9";
                case "Gateway":
                    return "#fff3e0";
                default:
                    return "#f0f0f0";
            }
        }
    }

    function getNodeHeaderColor(type) {
        if (isDarkTheme) {
            switch (type) {
                case "Proxy":
                    return "#0d47a1"; // Darker blue
                case "Domain":
                    return "#1b5e20"; // Darker green
                case "Gateway":
                    return "#e65100"; // Darker orange
                default:
                    return "#555";
            }
        } else {
            switch (type) {
                case "Proxy":
                    return "#2196f3";
                case "Domain":
                    return "#4caf50";
                case "Gateway":
                    return "#ff9800";
                default:
                    return "#999";
            }
        }
    }

    // Toggle theme function
    function toggleTheme() {
        isDarkTheme = !isDarkTheme;
        render();
    }

    // Draw debug info
    function drawDebugInfo(ctx) {
        if (!isDebug) return;

        const infoX = 10;
        const infoY = dimensions.height - 70;

        // Update the background and text colors based on theme
        ctx.fillStyle = isDarkTheme
            ? "rgba(0, 0, 0, 0.7)"
            : "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(infoX - 5, infoY - 15, 300, 85);

        ctx.font = "12px monospace";
        ctx.fillStyle = "#fff"; // White text works for both themes
        ctx.fillText(
            `Canvas: ${dimensions.width}x${dimensions.height}`,
            infoX,
            infoY,
        );
        ctx.fillText(`Scale: ${scale.toFixed(2)}`, infoX, infoY + 20);
        ctx.fillText(
            `Offset: ${offsetX.toFixed(0)}, ${offsetY.toFixed(0)}`,
            infoX,
            infoY + 40,
        );
        ctx.fillText(
            `Nodes: ${nodes.length}, Connections: ${connections.length}`,
            infoX,
            infoY + 60,
        );

        // Update border color based on theme
        ctx.strokeStyle = isDarkTheme
            ? "rgba(255, 100, 100, 0.5)"
            : "rgba(255, 0, 0, 0.5)";
        ctx.lineWidth = 2;
        ctx.strokeRect(1, 1, dimensions.width - 2, dimensions.height - 2);
    }

    // Main render function
    function render() {
        if (!ctx) return;

        // Clear canvas
        ctx.clearRect(0, 0, dimensions.width, dimensions.height);

        // Draw background based on theme
        ctx.fillStyle = getBackgroundColor();
        ctx.fillRect(0, 0, dimensions.width, dimensions.height);

        // Save the current transformation matrix
        ctx.save();

        // Apply viewport transform
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Draw connections
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 2 / scale; // Adjust line width for scale

        connections.forEach((connection) => {
            const fromNode = nodesWithPortPositions.find(
                (n) => n.id === connection.from.nodeId,
            );
            const toNode = nodesWithPortPositions.find(
                (n) => n.id === connection.to.nodeId,
            );

            if (fromNode && toNode) {
                const fromPort = fromNode.outputs.find(
                    (p) => p.id === connection.from.portId,
                );
                const toPort = toNode.inputs.find(
                    (p) => p.id === connection.to.portId,
                );

                if (fromPort && toPort) {
                    const fromX = fromPort.position.x;
                    const fromY = fromPort.position.y;
                    const toX = toPort.position.x;
                    const toY = toPort.position.y;

                      drawBezierConnection(ctx, fromX, fromY, toX, toY);
                }
            }
        });

        // Draw nodes
        nodesWithPortPositions.forEach((node) => {
            // Node body
            ctx.fillStyle = getNodeColor(node.type);
            ctx.strokeStyle = isDarkTheme ? "#666" : "#999";
            ctx.lineWidth = 1 / scale;

            // Draw rounded rectangle
            roundRect(
                ctx,
                node.x,
                node.y,
                node.width,
                node.height,
                5,
                true,
                true,
            );

            // Node header
            ctx.fillStyle = getNodeHeaderColor(node.type);
            roundRect(ctx, node.x, node.y, node.width, 30, 5, true, false);

            // Node title
            ctx.fillStyle = "#fff";
            ctx.font = `bold ${14 / scale}px Arial`;
            ctx.fillText(
                `${node.type}: ${node.name}`,
                node.x + 10,
                node.y + 20,
            );

            // Draw fields
            if (node.field) {
                // Use theme-aware text color instead of hardcoded #333
                ctx.fillStyle = isDarkTheme ? "#e0e0e0" : "#333";
                ctx.font = `${12 / scale}px Arial`;

                node.field.forEach((field, index) => {
                    const y = node.y + 50 + index * 25;
                    ctx.fillText(
                        `${field.title}: ${field.value}`,
                        node.x + 15,
                        y,
                    );
                });
            }

            // Input ports
            if (node.inputs) {
                node.inputs.forEach((input) => {
                    // Port circle
                    ctx.fillStyle = isDarkTheme ? "#999" : "#666";
                    ctx.beginPath();
                    ctx.arc(
                        input.position.x,
                        input.position.y,
                        5 / scale,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();

                    // Port name - use theme-aware text color
                    ctx.fillStyle = isDarkTheme ? "#e0e0e0" : "#333";
                    ctx.font = `${12 / scale}px Arial`;
                    ctx.fillText(
                        input.name,
                        input.position.x + 10,
                        input.position.y + 4,
                    );
                });
            }

            // Output ports
            if (node.outputs) {
                node.outputs.forEach((output) => {
                    // Port circle
                    ctx.fillStyle = isDarkTheme ? "#999" : "#666";
                    ctx.beginPath();
                    ctx.arc(
                        output.position.x,
                        output.position.y,
                        5 / scale,
                        0,
                        Math.PI * 2,
                    );
                    ctx.fill();

                    // Port name - use theme-aware text color
                    ctx.fillStyle = isDarkTheme ? "#e0e0e0" : "#333";
                    ctx.font = `${12 / scale}px Arial`;
                    ctx.textAlign = "right";
                    ctx.fillText(
                        output.name,
                        output.position.x - 10,
                        output.position.y + 4,
                    );
                    ctx.textAlign = "left";
                });
            }
        });

        // Restore the transformation matrix
        ctx.restore();

        // Draw debug information
        drawDebugInfo(ctx);
    }

    // Handle canvas double click for node editing
    function handleCanvasDoubleClick(e) {
        // Check if double-clicked on a node
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const world = screenToWorld(screenX, screenY);

        const clickedNode = nodesWithPortPositions.find(
            (node) =>
                world.x >= node.x &&
                world.x <= node.x + node.width &&
                world.y >= node.y &&
                world.y <= node.y + node.height,
        );

        if (clickedNode) {
            handleNodeDoubleClick(e, clickedNode.id);
        }
    }

    // Delete a node and its connections
    function deleteNode() {
        if (!editingNode) return;

        // Remove any connections involving this node
        connections = connections.filter(
            (conn) =>
                conn.from.nodeId !== editingNode.id &&
                conn.to.nodeId !== editingNode.id,
        );

        // Remove relations to this node from other nodes
        nodes = nodes.map((node) => {
            if (node.relation && node.relation.includes(editingNode.id)) {
                return {
                    ...node,
                    relation: node.relation.filter(
                        (rel) => rel !== editingNode.id,
                    ),
                };
            }
            return node;
        });

        // Remove the node itself
        nodes = nodes.filter((node) => node.id !== editingNode.id);

        editingNode = null;
    }

    // Export nodes to JSON
    function exportNodes() {
        const exportData = nodes.map(({ id, type, name, relation, field }) => ({
            id,
            type,
            name,
            relation,
            field,
        }));

        const jsonString = JSON.stringify(exportData, null, 2);
        const blob = new Blob([jsonString], { type: "application/json" });
        const url = URL.createObjectURL(blob);

        const a = document.createElement("a");
        a.href = url;
        a.download = "node-editor-export.json";
        a.click();

        URL.revokeObjectURL(url);
    }

    // Function to update position of invisible port interaction divs
    function getPortDivStyle(port, isInput) {
        const screen = worldToScreen(port.position.x, port.position.y);
        return `position: absolute; left: ${screen.x - 10}px; top: ${screen.y - 10}px; width: 20px; height: 20px; cursor: ${isInput ? "pointer" : "crosshair"}; z-index: 10;`;
    }

    // Setup on component mount
    onMount(() => {
        ctx = canvas.getContext("2d");

        // Initialize canvas size from container
        if (container) {
            dimensions = {
                width: container.clientWidth,
                height: container.clientHeight,
            };
            canvas.width = dimensions.width;
            canvas.height = dimensions.height;
        }

        setupResizeObserver();
        
        // Initialize node positions in a grid before layout
        initializeNodePlacement();

        // Auto layout and fit view after a short delay to ensure layout is complete
        setTimeout(() => {
            autoLayout(); // Apply auto layout with enhanced collision detection
            
            // Make sure fitView is called AFTER autoLayout is complete
            setTimeout(() => {
                fitView(); // Ensure the view is properly fit to show all nodes
                console.log("View fitted automatically");
            }, 100);
            
            console.log("Auto-layout applied with enhanced collision avoidance");
        }, 300);
    });
    
    // Clean up on component destruction
    onDestroy(() => {
        if (resizeObserver) {
            resizeObserver.disconnect();
        }
    });

    // Reactive statements to trigger re-render when state changes
    $: if (ctx && nodesWithPortPositions) render();
    $: if (ctx && connections) render();
    $: if (ctx && mousePos) render();
    $: if (ctx && dimensions) render();
</script>

<div
    bind:this={container}
    class="w-full h-full flex flex-col"
    style="background-color: {getBackgroundColor()}; color: {getTextColor()};"
>
    <div
        class="p-3 border-b flex justify-between"
        style="border-color: {isDarkTheme ? '#444' : '#ddd'};"
    >
        <div class="flex space-x-2">
            <button
                class="bg-blue-500 text-white px-3 py-1 rounded"
                on:click={fitView}
            >
                Fit View
            </button>
            <button
                class="bg-blue-500 text-white px-3 py-1 rounded ml-2"
                on:click={resetView}
            >
                Reset View
            </button>
            <button
                class="bg-purple-500 text-white px-3 py-1 rounded ml-2"
                on:click={autoLayout}
            >
                Auto Layout
            </button>
            <div class="flex items-center ml-4">
                <button
                    class="bg-gray-200 text-gray-700 px-3 py-1 rounded-l hover:bg-gray-300"
                    style="background-color: {isDarkTheme
                        ? '#444'
                        : '#e0e0e0'}; color: {isDarkTheme ? '#ddd' : '#333'};"
                    on:click={() => {
                        scale = Math.max(0.1, scale * 0.8);
                        render();
                    }}
                >
                    -
                </button>
                <span
                    class="px-2 border-t border-b"
                    style="background-color: {isDarkTheme
                        ? '#333'
                        : '#fff'}; border-color: {isDarkTheme
                        ? '#555'
                        : '#ddd'};"
                >
                    {Math.round(scale * 100)}%
                </span>
                <button
                    class="px-3 py-1 rounded-r hover:bg-gray-300"
                    style="background-color: {isDarkTheme
                        ? '#444'
                        : '#e0e0e0'}; color: {isDarkTheme ? '#ddd' : '#333'};"
                    on:click={() => {
                        scale = Math.min(5, scale * 1.2);
                        render();
                    }}
                >
                    +
                </button>
            </div>
            <button
                class="px-3 py-1 rounded ml-4 hover:bg-gray-300"
                style="background-color: {isDarkTheme
                    ? '#444'
                    : '#e0e0e0'}; color: {isDarkTheme ? '#ddd' : '#333'};"
                on:click={() => {
                    isDebug = !isDebug;
                    render();
                }}
            >
                {isDebug ? "Hide" : "Show"} Debug
            </button>
            <button
                class="px-3 py-1 rounded ml-4 hover:bg-gray-300"
                style="background-color: {isDarkTheme
                    ? '#444'
                    : '#e0e0e0'}; color: {isDarkTheme ? '#ddd' : '#333'};"
                on:click={toggleTheme}
            >
                {isDarkTheme ? "☀️ Light" : "🌙 Dark"}
            </button>
        </div>
        <button
            class="text-white px-3 py-1 rounded"
            style="background-color: {isDarkTheme ? '#555' : '#333'};"
            on:click={exportNodes}
        >
            Export JSON
        </button>
    </div>
    <div
        class="flex-grow relative"
        style="background-color: {getBackgroundColor()};"
    >
        <canvas
            bind:this={canvas}
            on:mousedown={handleCanvasMouseDown}
            on:mousemove={handleMouseMove}
            on:mouseup={handleMouseUp}
            on:wheel={handleWheel}
            on:dblclick={handleCanvasDoubleClick}
            class="absolute top-0 left-0"
            style="cursor: {isPanning
                ? 'grabbing'
                : draggedNode !== null
                  ? 'grabbing'
                  : 'default'}"
        />

        <!-- Invisible port interaction layer with reduced functionality -->
        {#each nodesWithPortPositions as node (node.id)}
            {#if node.inputs}
                {#each node.inputs as input (input.id)}
                    <div style={getPortDivStyle(input, true)} />
                {/each}
            {/if}
            {#if node.outputs}
                {#each node.outputs as output (output.id)}
                    <div style={getPortDivStyle(output, false)} />
                {/each}
            {/if}
        {/each}
    </div>
</div>